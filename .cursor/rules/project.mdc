---
description: PromptPerfect project standards and evolvability patterns
alwaysApply: true
---

# PromptPerfect — Project Standards

## Tech Stack
- Next.js 14 App Router, TypeScript strict mode
- Tailwind CSS + shadcn/ui for all styling
- Vercel AI SDK for streaming LLM responses
- Gemini 2.5 Flash as default backend (via @ai-sdk/google)
- BYOK option: users can bring OpenAI or Anthropic keys too
- Supabase for feedback tracking and analytics

## Architecture — Evolvability First
- System prompts live in lib/prompts.ts as named exports. Adding a new mode = adding one export. Never hardcode prompts in routes.
- Provider logic lives in lib/providers.ts. Switching models = changing one line. The Vercel AI SDK abstracts providers behind a unified interface.
- The API route at app/api/optimize/route.ts accepts mode and provider as params. The frontend controls which mode/provider, making it trivial to extend.
- The ---EXPLANATION--- delimiter pattern: LLM returns optimized prompt + explanation in one stream, separated by this delimiter. Frontend parses and splits. Avoids a second API call.
- Feedback flows to Supabase optimization_logs table. This data drives future improvements.
- API key flow: Gemini key is server-side (env var, never exposed). BYOK keys pass from localStorage through request body — never persisted server-side.

## Code Style
- Functional components, TypeScript interfaces for all props
- Named exports only (no default exports except pages)
- 'use client' only when component needs browser APIs or hooks
- Files under 150 lines. One component per file.
- Early returns for error handling (guard clauses)

## Testing
- Use Vitest for unit tests, React Testing Library for component tests
- Test files live next to source: ComponentName.test.tsx
- Every hook and utility function gets unit tests
- Every API route gets integration tests

## Do NOT
- Install a database ORM — we use Supabase client directly
- Add authentication (it's open to everyone)
- Install Monaco editor or any heavy editor library
- Use Context/Redux — component-level state is fine for MVP
